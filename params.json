{
  "name": "Phpphp",
  "tagline": "A PHP VM implementation in PHP",
  "body": "PHPPHP\r\n======\r\n\r\n![YO DAWG](http://i.stack.imgur.com/JarJ0.jpg)\r\n\r\nA PHP VM implementation written in PHP.\r\n\r\nThis is a basic VM implemented in PHP using the [AST generating parser](https://github.com/nikic/PHP-Parser) developed by @nikic\r\n\r\nTo see what's supported so far, check out the opcodes.\r\n\r\nRight now, functions (definitions and calls) are supported, if statements (with basic boolean operations), if statements, as are variables and some basic variable operations...\r\n\r\nTo see the current state of the implementation versus the [Core Language Test Suite](https://github.com/php/php-src/tree/master/tests/lang), check out the [test results file](https://github.com/ircmaxell/PHPPHP/blob/master/test-results.html.md).\r\n\r\nInstallation\r\n============\r\n\r\nTo get the dependencies you need to use [composer](http://getcomposer.org):\r\n\r\n    curl -s https://getcomposer.org/installer | php\r\n    php composer.phar install\r\n\r\nGrab a cup of coffee while it runs, as it will fetch the entire PHP source code in the process which can take a while (~10 minutes).\r\n\r\nUsage\r\n=====\r\n\r\n## Linux/OSX\r\nUse the `php.sh` shell script to invoke php.php. This requires that `php` be in your system path.\r\n\r\n    ./php.sh -r \"var_dump('foo');\"\r\n\r\n## Windows\r\nUse the `php.bat` shell script to invoke php.php. This requires that `php.exe` be in your system path.\r\n\r\n    php.bat -r \"var_dump('foo');\"\r\n\r\n## Manual\r\nYou can run the implementation from the command line using the `php.php` file directly.\r\n\r\n    php php.php -r \"var_dump('foo');\"\r\n\r\nOr with a file:\r\n\r\n    php php.php ../test.php\r\n\r\nIt only supports relative includes off the base file now (no include path parsing *yet*)...\r\n\r\nTesting\r\n=======\r\n\r\n## run-tests\r\nTo run the test suite (which mostly fails right now), install composer using the `--dev` flag (to install the test suite along side php's source code). Then use the `run-tests.(sh|bat)` file to execute them.\r\n\r\n### Linux/OSX\r\n\r\n    ./run-tests.sh\r\n\r\n### Windows\r\nBefore running tests on Windows, some lines must be removed or commented out from `runtests.php` (if installed via composer it will be located in `vendor/php/php-src/runtests.php`). Starting from line 185:\r\n\r\n    if (function_exists('is_executable') && !is_executable($php)) {\r\n        error(\"invalid PHP executable specified by TEST_PHP_EXECUTABLE  = $php\");\r\n    }\r\n\r\nTo run test suite simply type\r\n\r\n    run-tests.bat\r\n\r\n### Manual\r\n\r\nIf you choose not to install php's source code from composer, but have it elsewhere in your system path, you can use it directly.\r\n\r\n    php path/to/runtests.php -p path/to/php.sh path/to/tests\r\n\r\nTODO:\r\n=====\r\nMajor things left to do:\r\n\r\n1. Implement references properly\r\n2. Implement Error Handling\r\n3. Implement classes and objects\r\n4. Implement Output Buffering.\r\n5. Refactor output control to use SAPI modules\r\n6. Implement true array hash tables (as opposed to the current reliance on the underlying hash table)\r\n7. Implement Error Handling\r\n8. Implement Exception Handling\r\n9. Implement parameter parsing for core functions\r\n\r\nFor The Love Of God, Why?\r\n=========================\r\n\r\nThere are a number of reasons why I did this...\r\n\r\n1. It was something that I always wanted to do. For no particular reason other than I wanted to do it. I knew it was possible, but possible and doing it are two very different things.\r\n2. It was far easier than I thought. The time to the initial commit (basic working VM) was only about 6 hours of work. So it's not like I spent a year building it...\r\n3. It could be a useful education tool. For me learning the intricacies of the [Zend VM](http://lxr.php.net/xref/PHP_TRUNK/Zend/) better (I know it fairly well, but knowing and building give two different amounts of knowledge). But also for teaching others how the VM works. By giving a PHP implementation reference, hopefully more people can understand how the C implementation works (they both operate off the same generic implementation at this point).\r\n4. It can enable certain interesting things. For example, we could hypothetically build an Opcode optimizer in PHP which parses the generated opcodes and optimizes things (removing redundant opcodes, statically compiling static expressions, etc). Then, we could build a PECL extension that would render those optimized opcodes directly into APC cache (or some other opcode cache mechanism).\r\n5. It can be used to quickly mock up future functionality changes. Consider that it's easier to alter a PHP VM simply because you don't need to worry about memory management at all. So whipping up a POC for a significant feature should be a lot easier in PHP than C (at least for many non-full-time C developers).\r\n6. It can be used to actually debug PHP code without working knowledge of GDB (and the underlying C structures). I wouldn't recommend this, as the chances of us getting it working 100% the same as the C implementation are practically 0, but it's a concept.\r\n7. It could wind up becoming a full implementation (like PYPY). If we can compile the implementation using HipHop, and do some other lower-level tricks, there's a chance we could achieve performance somewhere near the C implementation. I doubt it, but it's possible. Especially if we add a JIT component (or a way of rendering out to machine code certain opcodes)...\r\n8. **Why not?**\r\n\r\nAbout The Authors\r\n=================\r\n\r\nAnthony Ferrara - [@ircmaxell](https://twitter.com/ircmaxell) [blog.ircmaxell.com](http://blog.ircmaxell.com)\r\n\r\nNikita Popov - [@nikita_ppv](https://twitter.com/nikita_ppv) [nikic.github.com](http://nikic.github.com/)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}